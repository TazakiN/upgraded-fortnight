\section{Macaroons}
\label{sec:macaroons}

Macaroon adalah \textit{credential} otorisasi berbasis \textit{bearer} yang mendukung delegasi terdesentralisasi dalam sistem terdistribusi \autocite{birgisson2014macaroons}. Keunggulan utama Macaroon terletak pada penggunaan \textit{chained-HMAC}, yang memungkinkan proses delegasi bersifat terdesentralisasi secara efisien serta mendukung penambahan syarat \textit{caveat} yang sesuai dengan konteks penggunaan.

\subsection{Struktur Macaroon}
\label{subsec:struktur-macaroon}

Sebuah Macaroon $M$ didefinisikan dengan struktur:

\begin{equation*}
	M = (id, \, \mathrm{location}, \, \vec{c}, \, \mathrm{sig})
\end{equation*}

dimana $id$ adalah pengidentifikasi unik, $location$ adalah alamat layanan target, $\vec{c} = (c_1, c_2, \dots, c_n)$ adalah daftar \textit{caveat}, dan $sig$ adalah tanda tangan \autocite{birgisson2014macaroons}. Tanda tangan ($sig$) dihitung secara rekursif untuk menjamin integritas setiap penambahan batasan (\textit{caveat}):
\begin{align*}
	sig_0 & = \text{HMAC}(RootKey, id)    \\
	sig_n & = \text{HMAC}(sig_{n-1}, c_n)
\end{align*}
Dimana $RootKey$ adalah kunci rahasia yang digunakan untuk membangkitkan Macaroon awal. Struktur ini memungkinkan pemegang Macaroon (misalnya: Dokter A) menambahkan \textit{caveat} baru $c_{new}$ (misalnya: \texttt{time < 24h}) dan menghasilkan $sig_{new}$ untuk diberikan ke pihak lain (misalnya: Dokter B), tanpa mengetahui $RootKey$ yang asli. Mekanisme ini memungkinkan delegasi terdesentralisasi yang aman dan fleksibel. Gambaran mengenai delegasi dan atenuasi kewenangan melalui \textit{caveats} dapat dilihat pada Gambar \ref{fig:delegasi-macaroon}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{resources/chapter-2/macaroons.png}
	\caption{Contoh delegasi dan atenuasi kewenangan pada Macaroon. Klien C memegang Macaroon yang diturunkan dari layanan forum FS untuk mengakses data pada layanan TS dengan batasan waktu, lokasi IP, dan target data yang spesifik. \autocite{birgisson2014macaroons}}
	\label{fig:delegasi-macaroon}
\end{figure}

\subsection{Arsitektur Macaroons}
\label{subsec:arsitektur-macaroons}

Arsitektur Macaroons terdiri dari tiga komponen kunci: \textit{first-party caveats} yang diverifikasi oleh layanan target, \textit{third-party caveats} yang diverifikasi oleh layanan \textit{discharge} eksternal, dan struktur \textit{HMAC} berantai yang mengikat semua \textit{caveat} bersama-sama \autocite{birgisson2014macaroons}. Desain ini memungkinkan pembatasan otoritas yang fleksibel, menentukan bagaimana, oleh siapa, dan dalam konteks apa hak akses dapat dieksekusi.

\textit{First-party caveat} adalah syarat/ketentuan yang bisa diverifikasi langsung oleh pihak yang memegang kunci rahasia macaroon (biasanya \textit{resource server} atau \textit{authorization server} yang menerbitkan token) \autocite{birgisson2014macaroons}. Bentuknya biasanya sebuah predikat/kondisi seperti \texttt{user = 123}, \texttt{expires < t}, atau \texttt{method = GET} yang dapat dicek secara lokal ketika \textit{request} datang.

\textit{Third-party caveat} adalah syarat yang tidak bisa diverifikasi langsung oleh pemegang token, tetapi memerlukan bukti dari layanan pihak ketiga dalam bentuk \textit{discharge macaroon} \autocite{birgisson2014macaroons}. \textit{Caveat} ini berisi lokasi (URL/\textit{identifier} layanan ketiga), \textit{identifier} \textit{caveat}, dan kunci rahasia yang dipakai pihak ketiga untuk menandatangani \textit{discharge macaroon}.

\subsection{\textit{Asymmetric Macaroons}}
\label{subsec:asymmetric-macaroons}

Meskipun konstruksi asli Macaroons menawarkan efisiensi tinggi melalui penggunaan kriptografi simetris (HMAC), ketergantungan pada \textit{shared secret key} ($RootKey$) menimbulkan tantangan dalam manajemen kunci pada sistem berskala besar. Verifikator (layanan target) harus memiliki akses ke kunci rahasia yang sama dengan \textit{issuer} untuk memvalidasi token, yang menciptakan risiko SPoF pada sisi penyimpanan kunci.

Untuk mengatasi keterbatasan tersebut, konsep Macaroons telah dikembangkan lebih lanjut dengan mengintegrasikan kriptografi asimetris (\textit{Public-Key Cryptography}). Salah satu implementasi signifikan dari pendekatan ini adalah token Biscuit \autocite{couprie2019biscuit}. Dalam skema asimetris atau \textit{hybrid} ini, mekanisme pembangkitan tanda tangan awal ($sig_0$) dimodifikasi.

Alih-alih menggunakan kunci rahasia bersama, \textit{issuer} menggunakan kunci privat ($PrivKey$) untuk menandatangani elemen awal token. Persamaan dasar untuk inisiasi token berubah menjadi:

\begin{equation*}
	sig_0 = \text{Sign}(PrivKey_{issuer}, id)
\end{equation*}
atau dalam implementasi:
\begin{equation*}
	RootKey_{derived} = \text{Hash}(\text{Sign}(PrivKey_{issuer}, id))
\end{equation*}

Dengan mekanisme ini, proses verifikasi dapat dilakukan secara publik. Layanan target hanya memerlukan kunci publik ($PubKey_{issuer}$) untuk memvalidasi otentisitas akar token, tanpa perlu menyimpan rahasia apapun. Setelah akar tervalidasi secara asimetris, rantai \textit{caveat} selanjutnya ($sig_1, sig_2, \dots$) tetap dapat diproses menggunakan mekanisme HMAC standar untuk mempertahankan efisiensi komputasi. Pendekatan ini menggabungkan keamanan \textit{non-repudiation} dari kriptografi asimetris dengan performa atenuasi dari kriptografi simetris.